**姓名：胡子聪 	学号：2201210597    第九次作业**



### 作业题目

1.  实现目标检测算法

## 一、原理分析

1.获取当前路径

定义了一个 BASE_DIR 变量，用于获取当前 Python 脚本所在的目录路径。另外，还定义了一个 device 变量，根据当前环境是否支持 GPU，来决定使用 CPU 还是 GPU 运行程序：

```java
# 获取当前路径
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
```

2.classes_coco类别信息

定义了一个 COCO_INSTANCE_CATEGORY_NAMES 列表，其中包含了 80 种物体的类别信息，这些信息是用于在可视化时显示目标类别名称：

```javascript
# classes_coco类别信息
COCO_INSTANCE_CATEGORY_NAMES = [
    '__background__', 'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus',
    'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'N/A', 'stop sign',
    'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
    'elephant', 'bear', 'zebra', 'giraffe', 'N/A', 'backpack', 'umbrella', 'N/A', 'N/A',
    'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
    'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
    'bottle', 'N/A', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl',
    'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza',
    'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'N/A', 'dining table',
    'N/A', 'N/A', 'toilet', 'N/A', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',
    'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'N/A', 'book',
    'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
]
```

3.加载图片并进行预处理

首先，定义了要检测的图片的路径 `path_img`。然后，通过 `transforms` 模块中的 `Compose` 函数定义了预处理方法，其中 `ToTensor()` 函数将 PIL 图像对象转换成 Tensor 格式。

接着，使用 `Image` 模块的 `open()` 函数加载图片，并转换成 RGB 格式。最后，应用上述预处理方法 `preprocess` 将图片转换成 Tensor 格式，并将结果保存在 `img_chw` 变量中。

```java
# 检测图片路径
path_img = os.path.join(BASE_DIR, "moto.jpg")

# 预处理
preprocess = transforms.Compose([
    transforms.ToTensor(),
])

input_image = Image.open(path_img).convert("RGB")
img_chw = preprocess(input_image)
```

4.加载预训练模型

使用 PyTorch 的 `torchvision.models.detection` 模块中的 `fasterrcnn_resnet50_fpn` 函数加载 Faster R-CNN 的预训练模型，并将 `pretrained` 参数设置为 `True`。然后，使用 `eval()` 函数将模型设为评估模式。

如果检测到有可用的 GPU，将 `img_chw` 和 `model` 两个变量分别移动到 GPU 上。

```javascript
# 加载预训练模型
model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)
model.eval()

if torch.cuda.is_available():
    img_chw = img_chw.to('cuda')
    model.to('cuda')
```

5.前向传播

将 `img_chw` 封装到列表 `input_list` 中，并调用模型 `model` 进行前向传播。使用 `with torch.no_grad()` 上下文管理器可以减少计算图所需内存，并加快前向传播的速度。`output_list` 返回一个列表，包含了每个输入样本的输出。由于这里只输入了一张图片，因此取列表中的第一个元素 `output_list[0]` 即可。

然后，打印出输入图片 Tensor 的形状和前向传播所需时间。最后，通过字典 `output_dict` 取得了输出结果。其中，字典中的每个键值对对应了 Faster R-CNN 模型预测出来的信息，例如 `boxes` 表示检测到的物体在原图中的位置坐标.

```javascript
# 前向传播
input_list = [img_chw]
with torch.no_grad():
    tic = time.time()
    print("input img tensor shape:{}".format(input_list[0].shape))
    output_list = model(input_list)
    output_dict = output_list[0]
    print("pass: {:.3f}s".format(time.time() - tic))
    # 打印输出信息
    for k, v in output_dict.items():
        print("key:{}, value:{}".format(k, v))
```

6.取得相应结果

这部分代码将 Faster R-CNN 模型得到的输出结果 `output_dict` 中的 `boxes`, `scores`, 和 `labels` 分别取出来，并将它们都放到 CPU 上（因为在前面判断了 CUDA 是否可用，所以这里不需要再判断）。这三个变量将在可视化部分用到。

`out_boxes` 变量存储了检测框的位置信息，其形状为 `(num_boxes, 4)`，其中 `num_boxes` 为检测出的目标数目，而 `4` 则表示每个检测框的四个坐标值（左上角和右下角的横纵坐标）。

`out_scores` 变量存储了每个检测框对应的置信度得分，其形状为 `(num_boxes,)`，即每个检测框对应一个置信度得分。

`out_labels` 变量存储了每个检测框对应的类别标签，其形状也为 `(num_boxes,)`，即每个检测框对应一个类别标签。

```javascript
    # 取得相应结果
    out_boxes = output_dict["boxes"].cpu()
    out_scores = output_dict["scores"].cpu()
    out_labels = output_dict["labels"].cpu()
```

7.可视化结果

使用Matplotlib将检测结果绘制在输入图像上。循环遍历检测结果中的框，对于得分大于设定阈值的框，使用plt.Rectangle绘制矩形框，使用ax.text添加文本标签，最后显示可视化结果。其中，COCO_INSTANCE_CATEGORY_NAMES是一个已定义的类别名列表。

```javascript
    # 循环描框
    for idx in range(0, min(num_boxes, max_vis)):
        score = out_scores[idx].numpy()
        bbox = out_boxes[idx].numpy()
        class_name = COCO_INSTANCE_CATEGORY_NAMES[out_labels[idx]]

        if score < thres:
            continue

        ax.add_patch(plt.Rectangle((bbox[0], bbox[1]), bbox[2] - bbox[0], bbox[3] - bbox[1], fill=False,
                                   edgecolor='red', linewidth=3.5))
        ax.text(bbox[0], bbox[1] - 2, '{:s} {:.3f}'.format(class_name, score), bbox=dict(facecolor='blue', alpha=0.5),
                fontsize=14, color='white')
        ax.set_title("just a simple try about Faster Rcnn", fontsize=28, color='blue')
```

## 二、实验结果

1.原图像

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20230426095926585.png" alt="image-20230426095926585" style="zoom:47%;" />



2.检测后的图像

<img src="C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20230426095842692.png" alt="image-20230426095842692" style="zoom:47%;" />



## 三、完整代码

```java
"""
Faster rcnn实现目标检测
"""

import os
import time
import torch
import torchvision.transforms as transforms
import torchvision
from PIL import Image
from matplotlib import pyplot as plt
import cv2
# 获取当前路径
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


# classes_coco类别信息
COCO_INSTANCE_CATEGORY_NAMES = [
    '__background__', 'person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus',
    'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'N/A', 'stop sign',
    'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
    'elephant', 'bear', 'zebra', 'giraffe', 'N/A', 'backpack', 'umbrella', 'N/A', 'N/A',
    'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball',
    'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket',
    'bottle', 'N/A', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl',
    'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza',
    'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'N/A', 'dining table',
    'N/A', 'N/A', 'toilet', 'N/A', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',
    'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'N/A', 'book',
    'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'
]


if __name__ == "__main__":

    # 检测图片路径
    path_img = os.path.join(BASE_DIR, "moto.jpg")

    # 预处理
    preprocess = transforms.Compose([
        transforms.ToTensor(),
    ])

    input_image = Image.open(path_img).convert("RGB")
    img_chw = preprocess(input_image)

    # 加载预训练模型
    model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)
    model.eval()

    if torch.cuda.is_available():
        img_chw = img_chw.to('cuda')
        model.to('cuda')

    # 前向传播
    input_list = [img_chw]
    with torch.no_grad():
        tic = time.time()
        print("input img tensor shape:{}".format(input_list[0].shape))
        output_list = model(input_list)
        output_dict = output_list[0]
        print("pass: {:.3f}s".format(time.time() - tic))
        # 打印输出信息
        for k, v in output_dict.items():
            print("key:{}, value:{}".format(k, v))

    # 取得相应结果
    out_boxes = output_dict["boxes"].cpu()
    out_scores = output_dict["scores"].cpu()
    out_labels = output_dict["labels"].cpu()

    # 可视化
    fig, ax = plt.subplots(figsize=(12, 12))
    ax.imshow(input_image, aspect='equal')

    num_boxes = out_boxes.shape[0]
    max_vis = 400
    thres = 0.6

    # 循环描框
    for idx in range(0, min(num_boxes, max_vis)):
        score = out_scores[idx].numpy()
        bbox = out_boxes[idx].numpy()
        class_name = COCO_INSTANCE_CATEGORY_NAMES[out_labels[idx]]

        if score < thres:
            continue

        ax.add_patch(plt.Rectangle((bbox[0], bbox[1]), bbox[2] - bbox[0], bbox[3] - bbox[1], fill=False,
                                   edgecolor='red', linewidth=3.5))
        ax.text(bbox[0], bbox[1] - 2, '{:s} {:.3f}'.format(class_name, score), bbox=dict(facecolor='blue', alpha=0.5),
                fontsize=14, color='white')
        ax.set_title("just a simple try about Faster Rcnn", fontsize=28, color='blue')
    plt.show()
    plt.close()
```



